<launch>

<!--    Load M10iA-->
    <rosparam command="load" file="$(find fanuc_m10ia_support)/config/joint_names_m10ia.yaml" /> 	

    <arg name="sim" default="true" doc="Use industrial robot simulator instead of real robot" />
    <arg name="robot_ip" unless="$(arg sim)" doc="IP of controller (only required if not using industrial simulator)" />
    <arg name="use_bswap" unless="$(arg sim)" default="true" doc="If true, robot driver will byte-swap all incoming and outgoing data (only required if not using industrial simulator)" />

    <param name="robot_description" command="$(find xacro)/xacro --inorder '$(find plastic_picker)/urdf/workcell.xacro'" />

    <include file="$(find fanuc_m10ia_moveit_config)/launch/planning_context.launch" >
        <arg name="load_robot_description" value="false" />
    </include>
    
    
    
    <group if="$(arg sim)">
        <include file="$(find industrial_robot_simulator)/launch/robot_interface_simulator.launch" />
    </group>
    <group unless="$(arg sim)">
        <include file="$(find fanuc_m10ia_support)/launch/robot_interface_streaming_m10ia.launch" >
            <arg name="robot_ip" value="$(arg robot_ip)"/>
            <arg name="use_bswap"  value="$(arg use_bswap)" />
        </include>
    </group>
    
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" />
    
    <include file="$(find fanuc_m10ia_moveit_config)/launch/move_group.launch">
        <arg name="publish_monitored_planning_scene" value="true" />
    </include>
    
    <include file="$(find fanuc_m10ia_moveit_config)/launch/moveit_rviz.launch">
        <arg name="config" value="true"/>
    </include>
    
    <include ns="move_group" file="$(find fanuc_m10ia_moveit_config)/launch/sensor_manager.launch.xml">
        <arg name="moveit_sensor_manager" value="fanuc_m10ia" />
    </include>


    
<!--Broadcast transform for PP V4 setup    -->
    <node pkg="tf2_ros" type="static_transform_publisher" name="kinect2robot_broadcaster" args="1.20 0.03 1.65 1.5708 0 3.39 world kinect2_ir_optical_frame" />
    
<!--    iai Kinect2 data-->
    <arg name="base_name"         default="kinect2"/>
    <arg name="sensor"            default=""/>
    <arg name="publish_tf"        default="false"/>
    <arg name="base_name_tf"      default="$(arg base_name)"/>
    <arg name="fps_limit"         default="5"/>
    <arg name="calib_path"        default="$(find kinect2_bridge)/data/"/>
    <arg name="use_png"           default="false"/>
    <arg name="jpeg_quality"      default="90"/>
    <arg name="png_level"         default="1"/>
    <arg name="depth_method"      default="default"/>
    <arg name="depth_device"      default="-1"/>
    <arg name="reg_method"        default="default"/>
    <arg name="reg_device"        default="-1"/>
    <arg name="max_depth"         default="1.31"/>
    <arg name="min_depth"         default=".75"/>
    <arg name="queue_size"        default="1"/>
    <arg name="bilateral_filter"  default="true"/>
    <arg name="edge_aware_filter" default="true"/>
    <arg name="worker_threads"    default="1"/>
    <arg name="machine"           default="localhost"/>
    <arg name="nodelet_manager"   default="$(arg base_name)"/>
    <arg name="start_manager"     default="true"/>
    <arg name="use_machine"       default="true"/>
    <arg name="respawn"           default="true"/>
    <arg name="use_nodelet"       default="false"/>
    <arg name="output"            default="screen"/>

    <machine name="localhost" address="localhost" if="$(arg use_machine)"/>

    <node pkg="nodelet" type="nodelet" name="$(arg nodelet_manager)" args="manager"
        if="$(arg start_manager)" machine="$(arg machine)" output="log"/>

    <!-- Nodelet version of kinect2_bridge -->
<!--    <node pkg="nodelet" type="nodelet" name="$(arg base_name)_bridge" machine="$(arg machine)"-->
<!--        args="load kinect2_bridge/kinect2_bridge_nodelet $(arg nodelet_manager)"-->
<!--        respawn="$(arg respawn)" output="$(arg output)" if="$(arg use_nodelet)">-->
<!--        <param name="base_name"         type="str"    value="$(arg base_name)"/>-->
<!--        <param name="sensor"            type="str"    value="$(arg sensor)"/>-->
<!--        <param name="publish_tf"        type="bool"   value="$(arg publish_tf)"/>-->
<!--        <param name="base_name_tf"      type="str"    value="$(arg base_name_tf)"/>-->
<!--        <param name="fps_limit"         type="double" value="$(arg fps_limit)"/>-->
<!--        <param name="calib_path"        type="str"    value="$(arg calib_path)"/>-->
<!--        <param name="use_png"           type="bool"   value="$(arg use_png)"/>-->
<!--        <param name="jpeg_quality"      type="int"    value="$(arg jpeg_quality)"/>-->
<!--        <param name="png_level"         type="int"    value="$(arg png_level)"/>-->
<!--        <param name="depth_method"      type="str"    value="$(arg depth_method)"/>-->
<!--        <param name="depth_device"      type="int"    value="$(arg depth_device)"/>-->
<!--        <param name="reg_method"        type="str"    value="$(arg reg_method)"/>-->
<!--        <param name="reg_device"        type="int"    value="$(arg reg_device)"/>-->
<!--        <param name="max_depth"         type="double" value="$(arg max_depth)"/>-->
<!--        <param name="min_depth"         type="double" value="$(arg min_depth)"/>-->
<!--        <param name="queue_size"        type="int"    value="$(arg queue_size)"/>-->
<!--        <param name="bilateral_filter"  type="bool"   value="$(arg bilateral_filter)"/>-->
<!--        <param name="edge_aware_filter" type="bool"   value="$(arg edge_aware_filter)"/>-->
<!--        <param name="worker_threads"    type="int"    value="$(arg worker_threads)"/>-->
<!--    </node>-->
    
    <!-- Node version of kinect2_bridge -->
  <node pkg="kinect2_bridge" type="kinect2_bridge" name="$(arg base_name)_bridge" machine="$(arg machine)"
        respawn="$(arg respawn)" output="$(arg output)" unless="$(arg use_nodelet)">
    <param name="base_name"         type="str"    value="$(arg base_name)"/>
    <param name="sensor"            type="str"    value="$(arg sensor)"/>
    <param name="publish_tf"        type="bool"   value="$(arg publish_tf)"/>
    <param name="base_name_tf"      type="str"    value="$(arg base_name_tf)"/>
    <param name="fps_limit"         type="double" value="$(arg fps_limit)"/>
    <param name="calib_path"        type="str"    value="$(arg calib_path)"/>
    <param name="use_png"           type="bool"   value="$(arg use_png)"/>
    <param name="jpeg_quality"      type="int"    value="$(arg jpeg_quality)"/>
    <param name="png_level"         type="int"    value="$(arg png_level)"/>
    <param name="depth_method"      type="str"    value="$(arg depth_method)"/>
    <param name="depth_device"      type="int"    value="$(arg depth_device)"/>
    <param name="reg_method"        type="str"    value="$(arg reg_method)"/>
    <param name="reg_device"        type="int"    value="$(arg reg_device)"/>
    <param name="max_depth"         type="double" value="$(arg max_depth)"/>
    <param name="min_depth"         type="double" value="$(arg min_depth)"/>
    <param name="queue_size"        type="int"    value="$(arg queue_size)"/>
    <param name="bilateral_filter"  type="bool"   value="$(arg bilateral_filter)"/>
    <param name="edge_aware_filter" type="bool"   value="$(arg edge_aware_filter)"/>
    <param name="worker_threads"    type="int"    value="$(arg worker_threads)"/>
  </node>

    <!-- sd point cloud (512 x 424) -->
    <node pkg="nodelet" type="nodelet" name="$(arg base_name)_points_xyzrgb_sd" machine="$(arg machine)"
        args="load depth_image_proc/point_cloud_xyzrgb $(arg nodelet_manager)" respawn="$(arg respawn)">
        <remap from="rgb/camera_info"             to="$(arg base_name)/sd/camera_info"/>
        <remap from="rgb/image_rect_color"        to="$(arg base_name)/sd/image_color_rect"/>
        <remap from="depth_registered/image_rect" to="$(arg base_name)/sd/image_depth_rect"/>
        <remap from="depth_registered/points"     to="$(arg base_name)/sd/points"/>
        <param name="queue_size" type="int" value="$(arg queue_size)"/>
    </node>

    <node name="segmentation_cpp" pkg="plastic_picker" type="segmentation_cpp" output="log" />
    <node name="segmentation" pkg="plastic_picker" type="segmentation" output="log" />
    <node name="object_sorter" pkg="plastic_picker" type="object_sorter" output="screen" launch-prefix="xterm -e" />

    <rosparam file="$(find plastic_picker)/config/dropzones.yaml" />

	
</launch>
